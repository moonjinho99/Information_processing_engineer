2.	데이터 입,출력 구현<br>

📝	데이터베이스 개요<br>
- 데이터베이스(DataBase) : 공동으로 사용될 데이터를 중복을 배제하여 통합하고, 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터<br>

📝	DBMS(DataBase Management System; 데이터베이스 관리 시스템)
-	정의(Definition) 기능 : 데이터의 형(Type) 구조에 대한 정의, 이용 방식, 제약 조건
-	조작(Manipilation) 기능 : 검색, 갱신, 삽입, 삭제
-	제어(Control) 기능 : 데이터 무결성, 보안, 권한 검사, 병행 제어

📝	데이터 독립성
-	논리적 독립성 : 데이터의 논리적 구조를 변경시키더라도 응용 프로그램은 영향을 받지 않음
-	물리적 독립성 : 디스크를 추가/변경하더라도 응용 프로그램은 영향을 받지 않음

📝	스키마(Schema)
-	외부 스키마 : 사용자, 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의
-	개념 스키마 : 데이터 베이스의 전체적인 논리적 구조, 모든 응용 프로그램
-	내부 스키마 : 물리적 저장장치의 입장 , 레코드 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서

📝	데이터베이스 설계<br>
🔍	고려사항 : 무결성, 일관성, 회복, 보안, 효율성, 데이터베이스 확장<br>
🔍	설계 순서<br>
-	요구 조건 분석 > 개념적 설계 > 논리적 설계 > 물리적 설계 > 구현
-	분석 : 데이터베이스가 필요한 용도를 분석
-	개념적 설계 : 개념 스키마, 트랜잭션 모델링, ERD
-	논리적 설계 : 특정 DBMS가 지원하는 논리적 자료 구조로 변환, 논리 스키마, 트랜잭션 인터페이스 설계
-	물리적 설계 : 논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환
-	구현 : 도출된 데이터베이스 스키마를 파일로 생성

📝	데이터 모델의 개념<br>
🔍	구성 요소 <br>
-	개체 : 데이터베이스에 표현하려는 것, 개념, 정보 단위
-	속성 : 데이터베이스를 구성하는 가장 작은 논리적 단위
-	속성의 수 : 디그리 or 차수
-	기본/설계/파생 , 기본키/외래키/일반
-	관계 : 개체와 개체 사이의 논리적인 연결
-	1:1 / 1:N / N:M , 종속/중복/재귀/배타

🔍	종류 : 개념적 데이터 모델(현실  추상적 개념) , 논리적 데이터 모델(개념적 구조  컴퓨터), 물리적 데이터 모델(컴퓨터에 데이터 저장)

🔍	표시할 요소
-	구조(Structure) : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현
-	연산(Operation) : 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세
-	제약 조건(Constraint) : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

🔍	E-R(개체-관계) 모델<br>
![image](https://github.com/user-attachments/assets/4a194beb-51b6-492c-b608-9429e957dd63)



📝	관계형 데이터베이스 구조 / 관계형 데이터 모델<br>
🔍	관계형 데이터베이스의 릴레이션 구조<br>
✏	튜플(Tuple)<br>
-	릴레이션을 구성하는 행
-	속성의 모임, 레코드
-	튜플의 수 : 카티널리티 or 기수 or 대응수

✏	속성(Attribute)<br>
-	데이터베이스를 구성하는 가장 작은 논리적 단위
-	개체의 특성을 기술
-	속성의 수 : 디그리  or 차수

✏	도메인(Domain)<br>
-	하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합

✏	릴레이션의 특징<br>
-	릴레이션에 포함된 튜플은 모두 상이하다.
-	튜플사이에는 순서가 없다.
-	릴레이션은 시간에 따라 변한다.
-	속성들간의 순서는 중요하지 않다.
-	속성의 명칭은 유일해야 하지만, 값은 동일해도 된다.
-	속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만 저장

🔍	관계형 데이터베이스의 제약 조건 – 키(Key)<br>
✏	후보키(Candidate Key) <br>
-	속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합
-	유일성(Unique) , 최소성(Minimality)

✏	기본키(Primary Key)<br>
-	후보키 중에서 특별히 선정된 주키

✏	대체키(Alternate Key)<br>
-	후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키

✏	슈퍼키(Super Key)<br>
-	속성들의 집합으로 구성된 키
-	유일성은 만족하지만 최소성은 만족하지 못함

✏	외래키(Foreign Key)<br>
-	다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합

🔍	관계형 데이터베이스의 제약 조건 – 무결성(Integrity)<br>
-	개체 무결성 : 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다
-	참조 무결성 : 외래키 값은 Null이나 참조 릴레이션의 기본키 값과 동일해야 함. 
-	도메인 무결성 : 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정
-	사용자 정의 무결성 : 속성 값들이 사용자가 정의한 제약조건에 만족되어야 한다는 규정
-	NULL 무결성 : 릴레이션의 특정 속성 값이 NULL이 될 수 없도록 하는 규정
-	고유 무결성 : 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 한다는 규정
-	키 무결성 : 하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다는 규정
-	관계 무결성 : 릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정

🔍	관계대수 및 관계해석<br>
✏	관계대수 : 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다.<br>
✏	순수 관계 연산자<br>
-	Select(σ) : 릴레이션 행에 해당하는 튜플(Tuple)을 구하는 것으로 수평 연산이라고도 함
-	Project(π) : 릴레이션의 열에 해당하는 속성을 추출하는 것이므로 수직 연산자라고도 함, 중복 제거
-	Join(⋈) : 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
-	Division(÷) : X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산

✏	일반 집합 연산자<br>
![image](https://github.com/user-attachments/assets/b960a79d-f85e-4e0e-9e6c-7f5f62eb5a96)

✏	관계해석(Relational Calculus) : 관계 데이터의 연산을 표현하는 방법, 비절차적

🔍	이상 / 함수적 종속<br>
✏	이상(Anomaly)<br>
-	삽입 이상(Insertion Action) : 테이블에 데이터 삽입 시, 의도와는 상관없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상
-	삭제 이상(Deletion Anomaly) : 연쇄삭제
-	갱신 이상(Update Anomaly) : 테이블에서 튜플이 있는 속성 값을 갱신할 때, 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생김

✏	함수적 종속(Functional Dependency)<br>
-	 테이블 : R , 속성 X,Y가 있고, X의 값 각각에 항상 속성 Y의 값이 오직 하나만 연관되어 있을때, Y는 X에 함수적 종속 , X가 Y를 함수적으로 결정한다고 하고, XY로 표기
-	 X는 결정자, Y는 종속자
-	완전 / 부분 함수적 종속 및 이해 / 이행적 함수적 종속
	
✏	완전 함수적 종속(Full Functional Dependency)<br>
-	어떤 속성이 기본키에 대해 완전히 종속적인 경우

✏	부분 함수적 종속(Partial Functional Dependency)<br>
-	어떤 속성이 속성 집합에 종속적이면서, 속성 집합중 일부와 종속적인 경우

Ex) PK : (학번, 과목번호) , 완전 함수적 종속(성적) , 부분 함수적 종속(학년) 
성적은 기본키 집합 2가지가 모두 있어야 추출가능 , 학년은 학번만 있어도 가능

✏	이행적 함수적 종속(Transitive Functional Dependency)
-	X > Y, Y > Z 일 때 X > Z

📝	정규화
-	테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정

✏	제 1정규형
-	 테이블 R에 속한 모든 속성의 도메인(Domain)이 원자 값(Automic Value)

✏	제 2정규형
-	 테이블 R이 제 1정규형이고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형

✏	제 3정규형
-	 테이블 R이 제 2정규형이고, 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속(Transitive Functional Dependency)을 만족하지 않는 정규형

✏	BCNF
-	 테이블 R에서 모든 결정자가 후보키(Candidate Key)인 정규형

✏	제 4정규형
-	 테이블 R에 다중 값 종속(MVD; Multi Valued Dependecy)A   B가 존재하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형

✏	제 5정규형
-	 테이블 R의 모든 조인 종속(JD; Join Dependency)이 R의 후보키를 통해서만 성립되는 정규형

✏	비정규 –(도메인이 원자값) > 1NF (부분적 함수 종속 제거) > 2NF (이행적 함수 종속 제거) > 3NF (결정자이면서 후보키가 아닌 것 제거) >  BCNF (모든 결정자가 후보키) > 4NF (다중 값 종속) > 5NF(조인 종속성 이용)
-	도부이결다조 > 두부이걸다줘?

📝	반정규화<br>
🔍	반정규화(=비정규화)<br>
-	정형화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위

🔍	테이블 통합<br>
-	 두 개의 테이블이 조인(Join)되어 사용되는 경우가 많을 경우 성능 향상을 위해 하나의 테이블로 만들어 사용

🔍	테이블 분할<br>
-	수평 분할<br>
✏	레코드(Record)를 기준으로 테이블을 분할<br>
-	수직 분할<br>
✏	하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할<br>

🔍	중복 테이블 추가<br>
-	집계 테이블의 추가<br>
✏	집계 데이터를 위한 테이블 생성, 트리거<br>
-	진행 테이블의 추가<br>
✏	이력 관리<br>
-	특정 부분만을 포함하는 테이블의 추가<br>
✏	특정 부분만으로 새로운 테이블을 생성<br>

🔍	중복 속성 추가<br>
-	조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가

📝	DB 관련 용어<br>
-	시스템 카탈로그(System Catalog) : 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스, 좁은 의미로는 데이터 사전<br>
-	메타 데이터(Meta-Data) : 시스템 카탈로그에 저장된 정보<br>
-	데이터 디렉터리(Data Directory) : 데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템<br>
-	인덱스(Index) : 데이터 레코드에 빠르게 접근하기 위해 <키 값, 포인터>쌍으로 구성되는 데이터 구조<br>
-	클러스터드 인덱스(Clustered Index) : 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식<br>
-	넌클러스터드 인덱스(Non-Clustered Index) : 인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식<br>
-	뷰(View) : 하나 이상의 기본 테이블로부터 유도된 가상 테이블<br>
✏	뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다<br>
-	클러스터(Cluster) : 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법<br>
-	데이터베이스 이중화(Database Replication) : 동일한 데이터베이스를 복제하여 관리<br>
✏	Eager 기법 : 데이터 변경 발생시 이중화된 모든 데이터베이스에 즉시 전달, 반영<br>
✏	Lazy 기법 : 트랜잭션 종료시 변경 사실을 새로운 트랜잭션을 만들어 전달<br>
-	클러스터링(Clustering) : 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술<br>
✏	고가용성(장애발생시 다른 서버가 받음) / 병렬 처리 클러스터링(한 작업을 여러 서버 분산처리)<br>
-	RTO(Recovery Time Objective, 목표 복구 시간) : 비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때 까지의 소요시간<br>
-	RPO(Recovery Point Objective, 목표 복구 시점) : 비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점<br>
-	복귀(Undo) : 로그(Log)에 보관한 정보를 이용하여 가장 최근에 변경된 내용부터 거슬러 올라가면서 트랜잭션 작업을 취소하여 원래의 데이터베이스로 복구<br>
-	재생(Redo) : 덤프(Dump)와 로그(Log)를 이용하여 가장 최근의 정상적인 데이터베이스로 회복 시킨 후 트랜잭션 재실행<br>
-	스토리지(Storage) : 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술<br>
✏	DAS(Direct Attached Storage) : 서버와 저장장치를 전용 케이블로 직접 연결하는 방식<br>
✏	NAS(Network attached Storage) : 서버와 저장장치를 네트워크 통해 연결하는 방식<br>
✏	SAN(Storage Area Network) : 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식<br>

📝	트랜잭션<br>
🔍	트랜잭션<br>
-	논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산

🔍	트랜잭션의 특성<br>
-	원자성(Atomicity)<br>
✏	트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit) 되든지 아니면 전혀 반영되지 않도록 복구(Rollback) 되어야 함

-	일관성(Consistency)<br>
✏	트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환

-	독립성(Isolation)<br>
✏	둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음

-	영속성(Durability)<br>
✏	성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

📝	파티션<br>
🔍	파티션(Partition)<br>
-	대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것

🔍	종류<br>
-	범위 분할(Range Partitioning)<br>
✏	지정한 열의 값을 기준으로 분할함
-	해시 분할(Hash Partitioning)<br>
✏	해시 함수를 적용한 결과 값에 따라 데이터 분할
-	조합 분할(Composite Partitioning)<br>
✏	범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할

📝	분산 데이터베이스 설계<br>
🔍	분산 데이터베이스 설계<br>
-	논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 사이트(Site)에 분산된 데이터베이스

🔍	목표<br>
-	위치 투명성(Location Transparency)<br>
✏	엑세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 엑세스할 수 있다<br>
-	중복 투명성(Replication Transparency)<br>
✏	동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행한다<br>
-	병행 투명성(Concurrency Transparency)<br>
✏	분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다<br>
-	장애 투명성(Failure Transparency)<br>
✏	트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다<br>

📝	데이터베이스 보안<br>
🔍	접근통제 기술<br>
-	임의 접근통제(DAC, Discretionary Access Control)<br>
✏	사용자의 신원에 따라 접근 권한 부여<br>
✏	데이터 소유자가 접근통제 권한 지정, 제어<br>

-	강제 접근통제(MAC, Mandatory Access Control)<br>
✏	주체와 객체의 등급을 비교하여 접근 권한 부여<br>
✏	시스템이 접근통제 권한 지정<br>

-	역할기반 접근통제(RBAC, Role Based Access Control)<br>
✏	사용자의 역할에 따라 접근 권한을 부여<br>
✏	중앙관리자가 접근통제 권한 지정<br>

🔍	접근통제 조건<br>
-	값 종속 통제(Value-Dependent Control) : 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우에 사용한다.
-	다중 사용자 통제(Multi-User Control) : 지정된 객체에 다수의 사용자가 동시에 접근을 요구하는 경우에 사용한다.
-	컨텍스트 기반 통제(Context-Based Control) : 특정 시간, 네트워크 주소, 접근 경로, 인증 수준 등에 근거하여 접근을 제어하는 방법

📝	자료 구조<br>
🔍	자료 구조의 분류<br>
![image](https://github.com/user-attachments/assets/722ef2b6-b9fd-4ef3-8b54-2fb18abd1e1a)

-	배열(Array) : 크기와 형(Type)이 동일한 자료들이 순서대로 나열된 자료의 집합
-	연속 리스트(Contiguous List) : 연속되는 기억장소에 저장되는 자료구조 / 삽입,삭제 시 자료의 이동이 필요
-	연결 리스트(Linked List) : 자료들을 임의의 기억공간에 기억시키되, 노드의 포인터부분을 이용하여 서로 연결시킨 자료 구조
-	스택(Stack) : 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조(후입선출, LIFO)
-	큐(Queue) : 리스트의 한쪽에서는 삽입 작업이, 다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조(선입선출, FIFO)
-	그래프(Graph) : 정점(Vertex)과 간선(Edge)의 두 집합으로 이루어지는 자료 구조
-	방항 그래프의 최대 간선 수 : n(n-1)
-	무방향 그래프에서 최대 간선 수 : n(n-1)/2
-	트리(Tree) <br>
![image](https://github.com/user-attachments/assets/fc529abf-c44f-4cb6-b8da-2bdf4104526c)
 

🔍	이진 트리<br>
![image](https://github.com/user-attachments/assets/91e78c4b-4cb2-4118-b528-ba5adbf04b9f)
<br>
🔍	트리의 운행법<br>
-	Preorder 운행 :  Root > Left > Right <br>
✏	A > B > C<br>
-	Inorder 운행 : Left > Root > Right<br>
✏	B > A > C<br>
-	Postorder 운행 : Left > Right > Root<br>
✏	B > C > A<br>

![image](https://github.com/user-attachments/assets/7ce63d07-9eba-4402-85b1-80dcd6937839)
<br>
🔍	수식의 표기법<br>
-	전위 표기법(PreFix) : 연산자 > Left > Right , +AB<br>
-	중위 표기법(InFix) : Left > 연산자 > Right, A+B<br>
-	후위 표기법(PostFix) : Left > Right > 연산자, AB+<br>

🔍	정렬(Sort)<br>
✏	삽입 정렬(Insertion Sort)<br>
-	이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬
-	평균, 최악 수행 시간 복잡도 : O(n2)
<br>

![image](https://github.com/user-attachments/assets/35dac9f3-ca22-4a6f-936d-a1a0294f611c)

✏	선택 정렬(Selection Sort)<br>
-	최소값을 찾아 첫 번째 레코드 위치에 놓고, 다시 최소값을 찾아 두 번 째 레코드 위치에 놓는 방식을 반복하여 정렬
-	평균, 최악 수행 시간 복잡도 : O(n2)
<br>

![image](https://github.com/user-attachments/assets/e9eefd0d-2d87-4bd9-9bcb-9f5d58501fc7)

✏	버블 정렬(Bubble Sort)<br>
-	인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정룍 방식
<br>

![image](https://github.com/user-attachments/assets/bf2b7b9f-ebf8-4ae1-afe2-13e5a269ab77)

<br>
✏	쉘 정렬(Shell Sort)<br>
-	매개변수의 값으로 서브파일을 구성하고, 각 서브파일을 삽입 정렬 방식으로 순서 배열하는 정렬 방식<br>
-	평균 수행 시간 복잡도 : O(n1.5)<br>
-	최악 수행 시간 복잡도 : O(n2)<br>
<br>
✏	퀵 정렬(Quick Sort)<br>
-	키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 서브 파일에 분해시키는 정렬 방식<br>
-	평균 수행 시간 복잡도 : O(nlog2n)<br>
-	최악 수행 시간 복잡도 : O(n2)<br>
<br>
✏	힙 정렬(Heap Sort)<br>
-	전이진 트리를 이용한 정렬 방식<br>
-	평균, 최악 수행 시간 복잡도 : O(nlog2n)<br>

✏	2-Way 합병 정렬(Merge Sort)<br>
-	이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식<br>
-	평균, 최악 수행 시간 복잡도 : O(nlog2n)<br>
<br>
✏	기수 정렬(Radix Sort) = Bucket Sort<br>
-	Queue를 이용하여 자릿수(Digit)별로 정렬하는 방식<br>
-	평균, 최악 수행 시간 복잡도 : O(dn)<br>

