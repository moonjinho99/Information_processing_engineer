4.	서버 프로그램 구현
	소프트웨어 아키텍처
	소프트웨어 아키텍처
-	소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체

	소프트웨어 아키텍처 설계의 기본 원리
-	모듈화(Modularity) 
	 시스템의 기능들을 모듈 단위로 나누는 것
	모듈의 크기 ↓, 통합 비용 ↑ 
	모듈의 크기 ↑, 통합 비용 ↓, 모듈 하나의 개발 비용↑

-	추상화(Abstraction)
	전체적이고 포괄적인 개념을 설계한 후 구체화시켜 나가는 것
	과정 추상화 : 전반적인 흐름 파악
	데이터(자료) 추상화 : 데이터를 대표할 수 있는 표현으로 대체(속성, 용도 정의 X)
	제어 추상화 : 이벤트 발생의 정확한 절차나 방법을 정의하지 않고,  대표할 수 있는 표현으로 대체
		    ㄴ명칭은 제.과.자 로 암기! 정의는 추상화 대상으로 암기! (과정 – 흐름 , 데이터 – 데이터, 제어 – 이벤트)

-	단계적 분해(Stepwise Refinement)
	상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
	하향식 설계 전략

-	정보 은닉(Information Hiding)
	모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법


	소프트웨어 아키텍처의 품질 속성
-	시스템 측면
	성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성
-	비즈니스 측면
	시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정
-	아키텍처 측면
	개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성

	소프트웨어 아키텍처 설계 과정
-	설계 목표 설정  시스템 타입 결정  아키텍처 패턴 적용  서브시스템 구체화  검토

	협약(Contract)에 의한 설계
-	컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것
	선행 조선, 결과 조건, 불변 조건

	아키텍처 패턴
	레이어 패턴(Layer pattern)
-	시스템을 계층으로 구분하여 구성하는 패턴
-	OSI 참조 모델

	클라이언트-서버 패턴(Client-Server Pattern)
-	하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴

	파이프-필터 패턴(Pipe-Filter Pattern)
-	데이터 스트림 절차의 각 단계의 필터로 캡슐화하여 파이프를 통해 전송하는 패턴
-	UNIX의 쉘

	모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)
-	서브시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴

	마스터 슬레이브 패턴(Master-Slave Pattern)
-	슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식
-	장애 허용 시스템, 병렬 컴퓨팅 시스템

	브로커 패턴(Broker Pattern)
-	사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴
-	분산 환경 시스템

	피어-투-피어 패턴(Peer-To-Peer Pattern)
-	피어(Peer)라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수도 있는 패턴
-	파일 공유 네트워크

	이벤트-버스 패턴(Event-Bus Pattern)
-	소스가 특정 채널에 이벤트 메시지를 발행(Publish)하면, 해당 채널을 구독(Subscribe)한 리스너(Listener)들이 메시지를 받아 이벤트를 처리하는 패턴
-	알림 서비스

	블랙보드 패턴(Blackboard Pattern)
-	모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴
-	음성 인식, 차량 식별, 신호 해석

	인터프리터 패턴(Interpreter Pattern)
-	프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴
-	번역기, 컴파일러, 인터프리터

	객체지향(Object-Oriented)
	객체지향의 구성요소
-	객체(Object) : 데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈
-	클래스(Class) : 공통된 속성과 연산을 갖는 객체의 집합
-	메시지(Message) : 객체들 간의 상호작용을 하는데 사용되는 수단

	객체지향의 특징
-	캡슐화(Encapsulation) : 외부에서 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것
-	상속(Inheritance) : 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
-	다형성(Polymorphism) : 하나의 메시지에 대해 각각의 객체가 고유한 방법으로 응답할 수 있는 능력
-	연관성(Relationship)
	두 개 이상의 객체들이 상호 참조하는 관계
	연관화(Association) : is member of, 2개 이상의 객체가 상호 관련되어 있음을 의미
	분류화(Classfication) : is instance of, 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것
	집단화(Aggregation) : is part of, 관련 있는 객체들을 묶어 하나의 상위 객체를 구성
	일반화(Generalization) : is a, 공통적인 성질들로 추상화한 상위 객체를 구성
	특수화/상세화(Specialization) : is a, 상위 객체를 구체화하여 하위 객체를 구성

	객체지향 분석 및 설계
	객체지향 분석의 방법론
종류	내용
Rumbaugh(럼바우) 방법	분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행
Booch(부치) 방법	- 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용
- 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
Jacobson 방법	유스케이스(Use Case)를 강조하여 사용
Coad와 Yourdon 방법	E-R 다이어그램을 사용
Wirfs-Brock 방법	분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행

	럼바우(Rumbaugh)의 분석 기법
-	모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링
-	객체 모델링(Object Modeling) 
	정보 모델링(Information Modeling)
	시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시
-	동적 모델링(Dynamic Modeling)
	상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어, 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
-	기능 모델링(Functional Modeling)
	자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링

	SOLID
-	변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 원칙
-	종류
종류	내용
단일 책임 원칙(SRP)	객체는 단 하나의 책임만 가져야 한다는 원칙
개방-폐쇄 원칙(OCP)	기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙
리스코프 치환 원칙(LSP)	자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙
인터페이스 분리 원칙(ISP)	자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
의존 역전 원칙(DIP)	의존 관계 성립시 추상성 높은 클래스와 의존 관계를 맺어야 한다는 원칙




	모듈
	결합도
-	모듈간에 상호 의존하는 정도
-	약할수록 품질이 높고, 강할수록 품질이 낮음
ㄴ자.스.제.외.공.내(약함  강함)
-	종류
종료	내용
내용 결합도
(Content Coupling)	한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
공통(공유) 결합도
(Common Coupling)	-공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
-파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호 작용할 때의 결합도
외부 결합도
(External Coupling)	어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도
제어 결합도
(Control Coupling)	-어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도
-하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도 현상이 발생
스탬프(검인) 결합도
(Stamp Coupling)	모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
자료 결합도
(Data Coupling)	모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도

	응집도(Cohesion)
-	모듈의 내부 요소들이 서로 관련되어 있는 정도
-	강할수록 품질이 높고, 약할수록 품질이 낮음
ㄴ우.논.시.절.교.순.기(약함강함)
-	종류
종류	내용
기능적 응집도
(Functional Cohesion)	모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
순차적 응집도
(Sequential Cohesion)	모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
교환(통신)적 응집도
(Communication Cohesion)	동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
절차적 응집도
(Procedural Cohesion)	모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
시간적 응집도
(Temporal Cohesion)	특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
논리적 응집도
(Logical Cohesion)	유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
우연적 응집도
(Coincidential Cohesion)	모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

	팬인(Fan-In) / 팬아웃(Fan-Out)
-	팬인 : 어떤 모듈을 제어하는 모듈의 수, 높을수록 설계가 잘 된 모듈
-	팬아웃 : 어떤 모듈에 의해 제어되는 모듈의 수, 높은 경우 장애점이 발생할 가능성이 있음
 
-팬인 : A = 0 / B,C,D,E = 1 / F = 2
-팬아웃 : A = 3 / B,C,D = 1 / E,F = 0

	단위 모듈
	단위 모듈(Unit Module)
-	한 가지 동작을 수행하는 기능을 모듈로 구현한 것

	IPC(Inter-Process Communication)
-	모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
	Shared Memory : 공유 가능한 메모리를 구성하여 다수의 프로세스가 통신
	Socket : 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스간 통신
	Semaphores : 공유 자원에 대한 접근 제어를 통해 통신하는 방식
	Pipes&named Pipes : Pipe라고 불리는 선입선출로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식
	Message Queueing : 메시지가 발생하면 이를 전달하는 방식으로 통신

	테스트 케이스(Test Case)
-	소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서

	공통 모듈
-	재사용(Reuse)
	함수와 객체 : 클래스나 메소드 단위의 소스 코드를 재사용
	컴포넌트 : 독립적인 업무 또는 기능을 수행하는 실행 코드 기반으로 작성된 모듈, 인터페이스를 통해 통신하는 방식으로 재사용
	애플리케이션 : 공통된 기능을 제공하는 애플리케이션을 공유하는 방식으로 재사용

	코드
-	종류
종류	내용
순차 코드
(Sequence Code)	일정 기준에 따라 최초의 자료부터 차례로 일련 번호 부여
블록 코드
(Block Code)	공통성이 있는 것끼리 블록으로 구분, 블록 내에서 일련 번호 부여
10진 코드
(Decimal Code)	10진 분할 방법을 필요한 만큼 반복
그룹 분류 코드
(Group Classification)	일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분, 일련 번호 부여
연상 코드
(Mnemonic Code)	명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드 부여
표의 숫자 코드
(Significant Digit Code)	물리적 수치를 그대로 코드에 적용
합성 코드
(Combined Code)	2개 이상의 코드를 조합하여 만드는 방법


	디자인 패턴
	디자인 패턴
-	모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제

	생성 패턴(Creational Pattern)
-	클래스나 객체의 생성에 참조 과정 정의
추상 팩토리
(Abstract Factory)	구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
빌더
(Builder)	작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함

팩토리 메소드
(Factory Method)	-객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화
-상위 클래스에서 인터페이스만 정의, 서브 클래스가 생성
프로토타입
(Prototype)	원본 객체를 복제하는 방법으로 객체를 생성
싱글톤
(Singleton)	하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음
ㄴ 추.빌.팩.프.싱

	구조 패턴(Structural Pattern)
-	클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴
어댑터
(Adapter)	 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
브리지
(Bridge)	구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
컴포지트
(Composite)	여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
데코레이터
(Decorator)	객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
퍼싸드
(Façade)	복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
플라이웨이트
(Flyweight)	인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한한 공유해서 사용함으로써 메모리를 절약하는 패턴
프록시
(Proxy)	접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴, 대리자
ㄴ 데.브.컴.퍼.플.어.프

	행위 패턴(Behavioral Pattern)
-	클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의
책임 연쇄
(Chain of Responsibility)	요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
커맨드
(Command)	요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
인터프리터
(Interpreter)	언어에 문법 표현을 정의하는 패턴
반복자
(Iterator)	자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
중재자
(Mediator)	수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
메멘토
(Memento)	특정 시점에서 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공, Ctrl+Z
옵서버
(Observer)	한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
상태
(State)	객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
전략
(Strategy)	동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
템플릿 메소드
(Template Method)	상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
방문자
(Visitor)	각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
ㄴ 책.커.인.반.중.메.옵.상.전.템.방

	개발 지원 도구
	빌드 도구
-	Ant(Another Neat Tool) : 자바 프로잭트의 공식적인 빌드 도구
-	Maven : Ant의 대안, 의존성(Dependency)을 설정하여 라이브러리 관리
-	Gradle : Ant, Maven을 보완하여 개발, 그루비(Groovy)기반 빌드 스크립트 사용

	서버 개발
	서버 개발 프레임워크
-	Spring : JAVA 기반
-	Node.js : Javascript 기반
-	Django : Python 기반
-	Codeigniter : PHP 기반
-	Ruby on Rails : Ruby 기반

	Crontab 명령어 작성방법
[분] [시] [일] [월] [요일] [명령어] 
Ex) * * * * * /root/com_1.sh   매월 매일 매시 매분 마다 com_1.sh 실행
Ex) 30 */3 * * * /root/com_1.sh  매월 매일 0:30부터 3시간마다 com_1.sh 실행
Ex) 18-23 20 * * /root/com_1.sh  매월 20일 18시~23시 사이에 매분마다 com_1.sh를 실행
Ex) 30 23 25 4,9,11 * /root/com_1.sh  4/9/11월의 25일 23시 30분에 com_1.sh를 실행
